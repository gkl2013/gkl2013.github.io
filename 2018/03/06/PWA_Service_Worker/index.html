<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>PWA Service Worker详解 | GKL2013 BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="gkl2013"><meta name="designer" content="gkl2013"><meta name="keywords" content="gkl2013, 博客, nodejs, vue, html5, javascript, angularjs"><meta name="description" content="我的梦想是永不停歇的疯狂！"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="cache-control" content="max-age=600"><link rel="canonical" href="https://gkl2013.top/2018/03/06/PWA_Service_Worker/index.html"><link rel="icon" type="image/png" href="http://oxb3h3vd2.bkt.clouddn.com/favicon_icon.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="gkl2013"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?87cab67e027e09ac1c5fba3606beecea";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="gkl2013" alt="gkl2013"><img src="http://oxb3h3vd2.bkt.clouddn.com/logo2.png" alt="gkl2013"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="http://oxb3h3vd2.bkt.clouddn.com/18-03-07-pwa.png" alt="PWA Service Worker详解"></div><header class="post__info"><h1 class="post__title">PWA Service Worker详解</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" href="/">gkl2013</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-03-06</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/PWA/">PWA</a></li><li class="mark__item"><a href="/tags/Service-Worker/">Service Worker</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="1-什么是-Service-Worker"><a href="#1-什么是-Service-Worker" class="headerlink" title="1 什么是 Service Worker"></a>1 什么是 Service Worker</h2><p>Service Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。该 WEB API 标准起草于 2013 年，于 2014 年纳入 W3C WEB 标准草案，当前还在草案阶段。</p><p>Service Worker 最主要的特点是：在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。</p><p>基于 Service Worker API 的特性，结合 Fetch API、Cache API、Push API、postMessage API 和 Notification API，可以在基于浏览器的 web 应用中实现如离线缓存、消息推送、静默更新等 native 应用常见的功能，以给 web 应用提供更好更丰富的使用体验。</p><h3 id="1-1-Service-Worker-特点"><a href="#1-1-Service-Worker-特点" class="headerlink" title="1.1 Service Worker 特点"></a>1.1 Service Worker 特点</h3><ul><li>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 <code>localhost</code>)</li><li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li><li>单独的作用域范围，单独的运行环境和执行线程</li><li>不能操作页面 DOM。但可以通过事件机制来处理</li></ul><h3 id="1-2-Service-Worker-浏览器支持情况"><a href="#1-2-Service-Worker-浏览器支持情况" class="headerlink" title="1.2 Service Worker 浏览器支持情况"></a>1.2 Service Worker 浏览器支持情况</h3><p>除了 Safari 和 IE/Edge，大部分现代浏览器都已经得到了支持。请参考：<a href="http://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">http://caniuse.com/#feat=serviceworkers</a><br><img src="http://oxb3h3vd2.bkt.clouddn.com/18-03-06/caniuse_service_worker.png" alt=""></p><h3 id="1-3-什么是-PWA"><a href="#1-3-什么是-PWA" class="headerlink" title="1.3 什么是 PWA"></a>1.3 什么是 PWA</h3><p>谷歌给以 Service Worker API 为核心实现的 web 应用取了个高大上的名字：<code>Progressive Web Apps</code>（PWA，渐进式增强 WEB 应用），并且在其主要产品上进行了深入的实践。那么，符合 PWA 的应用特点是什么？以下为来自谷歌工程师的解答。</p><p>Progressive Web Apps 是:</p><ul><li><strong>渐进增强</strong> – 能够让每一位用户使用，无论用户使用什么浏览器，因为它是始终以渐进增强为原则。</li><li><strong>响应式用户界面</strong> – 适应任何环境：桌面电脑，智能手机，笔记本电脑，或者其他设备。</li><li><strong>不依赖网络连接</strong> – 通过 Service Workers 可以在离线或者网速极差的环境下工作。</li><li><strong>类原生应用</strong> – 有像原生应用般的交互和导航给用户原生应用般的体验，因为它是建立在 app shell model 上的。</li><li><strong>持续更新</strong> – 受益于 Service Worker 的更新进程，应用能够始终保持更新。</li><li><strong>安全</strong> – 通过 HTTPS 来提供服务来防止网络窥探，保证内容不被篡改。</li><li><strong>可发现</strong> – 得益于 W3C manifests 元数据和 Service Worker 的登记，让搜索引擎能够找到 web 应用。</li><li><strong>再次访问</strong> – 通过消息推送等特性让用户再次访问变得容易。</li><li><strong>可安装</strong> – 允许用户保留对他们有用的应用在主屏幕上，不需要通过应用商店。</li><li><strong>可连接性</strong> – 通过 URL 可以轻松分享应用，不用复杂的安装即可运行。</li></ul><p>如有兴趣，可进一步研究一下 Google plus 相关的表现。</p><h2 id="2-Service-Worker-的生命周期"><a href="#2-Service-Worker-的生命周期" class="headerlink" title="2 Service Worker 的生命周期"></a>2 Service Worker 的生命周期</h2><p>参考 Service Worker 的生命周期，使用 Service Worker 大概需要如下几个过程。</p><blockquote><p>install -&gt; installed -&gt; actvating -&gt; Active -&gt; Activated -&gt; Redundant</p></blockquote><p>Service Worker 的生命周期示意图: <img src="http://oxb3h3vd2.bkt.clouddn.com/service_worker_life.png" alt=""></p><p>特别说明，进入 Redundant (废弃)状态的原因可能为这几种：</p><ul><li>安装(install)失败</li><li>激活(activating)失败</li><li>新版本的 Service Worker 替换了它并成为激活状态</li></ul><h2 id="3-使用-Service-Worker"><a href="#3-使用-Service-Worker" class="headerlink" title="3 使用 Service Worker"></a>3 使用 Service Worker</h2><h3 id="3-1-注册"><a href="#3-1-注册" class="headerlink" title="3.1 注册"></a>3.1 注册</h3><p>在网站页面上注册实现 Service Worker 功能逻辑的脚本。例如注册 <code>/sw/sw.js</code> 文件，参考代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">        .register(<span class="string">'/sw/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">registration</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其实关键代码只有一行：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">'/sw/sw.js'</span>)</span><br></pre></td></tr></table></figure><p></p><p>chrome 浏览器下，注册成功后，可以打开 <code>chrome://serviceworker-internals/</code> 查看浏览器的 Service Worker 信息。<br>注意：<br>Service Worker 的注册路径决定了其 <code>scope</code> 默认作用范围。示例中 <code>sw.js</code> 是在 <code>/sw/</code> 路径下，这使得该 Service Worker 默认只会收到 <code>/sw/</code> 路径下的 fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。</p><p>如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。</p><p>另外应意识到这一点：Service Worker 没有页面作用域的概念，作用域范围内的所有页面请求都会被当前激活的 Service Worker 所监控。</p><h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><p>前一步在页面中仅注册了 <code>sw.js</code> 脚本，具体的逻辑行为则在 <code>sw.js</code> 内实现。那么这里面要做什么呢？参考示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于标注创建的缓存，也可以根据它来建立版本规范</span></span><br><span class="line"><span class="keyword">const</span> CACHE_NAME = <span class="string">"blog_cache_v1.0.0"</span>;</span><br><span class="line"><span class="comment">// 列举要默认缓存的静态资源，一般用于离线使用</span></span><br><span class="line"><span class="keyword">const</span> urlsToCache = [</span><br><span class="line">    <span class="string">'/offline.html'</span>,</span><br><span class="line">    <span class="string">'/offline.png'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// self 为当前 scope 内的上下文</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="comment">// event.waitUtil 用于在安装成功之前执行一些预装逻辑</span></span><br><span class="line">    <span class="comment">// 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span></span><br><span class="line">    <span class="comment">// 安装成功后 ServiceWorker 状态会从 installing 变为 installed</span></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 使用 cache API 打开指定的 cache 文件</span></span><br><span class="line">        caches.open(CACHE_NAME).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(cache);</span><br><span class="line">            <span class="comment">// 添加要缓存的资源列表</span></span><br><span class="line">            <span class="keyword">return</span> cache.addAll(urlsToCache);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，示例中在文件 <code>sw.js</code> 内监听了 <code>install</code> 事件。当 <code>sw.js</code> 被安装时会触发 <code>install</code> 事件，监听该事件可执行安装时要做的事情。示例中是缓存用于离线时使用的静态资源，这也是最常见的行为。</p><p>需要注意的是，只有 <code>urlsToCache</code> 中的文件全部安装成功，Service Worker 才会认为安装完成。否则会认为安装失败，安装失败则进入 <code>redundant</code> (废弃)状态。所以这里应当尽量少地缓存资源(一般为离线时需要但联网时不会访问到的内容)，以提升成功率。</p><p>安装成功后，即进入等待(waiting)或激活(active)状态。在激活状态可通过监听各种事件，实现更为复杂的逻辑需求。具体参见后文<code>事件处理</code>部分。</p><h3 id="3-3-Service-Worker-的更新"><a href="#3-3-Service-Worker-的更新" class="headerlink" title="3.3 Service Worker 的更新"></a>3.3 Service Worker 的更新</h3><p>如果 <code>sw.js</code> 文件的内容有改动，当访问网站页面时浏览器获取了新的文件，它会认为有更新，于是会安装新的文件并触发 <code>install</code> 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来打开的页面里生效。</p><p>如果希望在有了新版本时，所有的页面都得到及时更新怎么办呢？</p><p>可以在 <code>install</code> 事件中执行 <code>skipWaiting</code> 方法跳过 waiting 状态，然后会直接进入 <code>activate</code> 阶段。接着在 <code>activate</code> 事件发生时，通过执行 <code>clients.claim</code> 方法，更新所有客户端上的 Service Worker。示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装阶段跳过等待，直接进入 active</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(self.skipWaiting());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, evnet =&gt; event.waitUntil(</span><br><span class="line">    <span class="built_in">Promise</span>.all([</span><br><span class="line">        <span class="comment">// 更新客户端</span></span><br><span class="line">        clients.claim(),</span><br><span class="line">        <span class="comment">// 清理旧版本</span></span><br><span class="line">        caches.keys().then(<span class="function"><span class="params">cacheList</span> =&gt;</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">            cacheList.map(<span class="function"><span class="params">cacheName</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cacheName !== CACHE_NAME) &#123;</span><br><span class="line">                    caches.delete(cacheName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ))</span><br><span class="line">    ])</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p></p><p>另外要注意一点，<code>sw.js</code> 文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件。这会导致更新得不到响应。如遇到该问题，可尝试这么做：在 webserver 上添加对该文件的过滤规则，不缓存或设置较短的有效期。注意，不要想着不同版本使用不同的文件名称，这会带来混乱的问题。</p><p>关于 <code>clients.claim</code>： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clients/claim" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Clients/claim</a></p><p><strong>手动更新</strong></p><p>其实在页面中，也可以手动来管理更新。参考如下示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> version = <span class="string">'1.0.1'</span>;</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="params">reg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'sw_version'</span>) !== version) &#123;</span><br><span class="line">        reg.update().then(<span class="function"><span class="params">()</span> =&gt;</span> localStorage.setItem(<span class="string">'sw_version'</span>, version));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="3-4-Service-Worker-相关事件处理"><a href="#3-4-Service-Worker-相关事件处理" class="headerlink" title="3.4 Service Worker 相关事件处理"></a>3.4 Service Worker 相关事件处理</h3><p>在安装过程中我们实现了资源缓存，安装完成后则进入了空闲阶段，此时可以通过监听各种事件实现各种逻辑。下面对常见的相关事件作简要介绍。</p><h3 id="3-4-1-install-事件"><a href="#3-4-1-install-事件" class="headerlink" title="3.4.1 install 事件"></a>3.4.1 install 事件</h3><p>当前脚本被安装时，会触发 <code>install</code> 事件，具体参考前文的 <code>安装</code> 部分的示例。</p><h3 id="3-4-2-fetch-事件"><a href="#3-4-2-fetch-事件" class="headerlink" title="3.4.2 fetch 事件"></a>3.4.2 fetch 事件</h3><p>当浏览器发起请求时，会触发 <code>fetch</code> 事件。</p><p>Service Worker 安装成功并进入激活状态后即运行于浏览器后台，可以通过 <code>fetch</code> 事件可以拦截到当前作用域范围内的 http/https 请求，并且给出自己的响应。结合 <code>Fetch API</code> ，可以简单方便地处理请求响应，实现对网络请求的控制。</p><p>参考下面的示例，这里实现了一个<code>缓存优先、降级处理</code>的策略逻辑：监控所有 http 请求，当请求资源已经在缓存里了，直接返回缓存里的内容；否则使用 <code>fetch API</code> 继续请求，如果是 图片或 css、js 资源，请求成功后将他们加入缓存中；如果是离线状态或请求出错，则降级返回预缓存的离线内容。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联网状态下执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlineRequest</span>(<span class="params">fetchRequest</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 fecth API 获取资源，以实现对资源请求控制</span></span><br><span class="line">    <span class="keyword">return</span> fetch(fetchRequest).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在资源请求成功后，将 image、js、css 资源加入缓存列表</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !response</span><br><span class="line">            || response.status !== <span class="number">200</span></span><br><span class="line">            || !response.headers.get(<span class="string">'Content-type'</span>).match(<span class="regexp">/image|javascript|test\/css/i</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> responseToCache = response.clone();</span><br><span class="line">        caches.open(CACHE_NAME)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                cache.put(event.request, responseToCache);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取失败，离线资源降级替换</span></span><br><span class="line">        offlineRequest(fetchRequest);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 离线状态下执行，降级替换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">offlineRequest</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用离线图片</span></span><br><span class="line">    <span class="keyword">if</span> (request.url.match(<span class="regexp">/\.(png|gif|jpg)/i</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> caches.match(<span class="string">'/images/offline.png'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用离线页面</span></span><br><span class="line">    <span class="keyword">if</span> (request.url.match(<span class="regexp">/\.html$/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> caches.match(<span class="string">'/test/offline.html'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(event.request)</span><br><span class="line">        .then(<span class="function"><span class="params">hit</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 返回缓存中命中的文件</span></span><br><span class="line">            <span class="keyword">if</span> (hit) &#123;</span><br><span class="line">                <span class="keyword">return</span> hit;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> fetchRequest = event.request.clone();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (navigator.online) &#123;</span><br><span class="line">                <span class="comment">// 如果为联网状态</span></span><br><span class="line">                <span class="keyword">return</span> onlineRequest(fetchRequest);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果为离线状态</span></span><br><span class="line">                <span class="keyword">return</span> offlineRequest(fetchRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>另外需要提到一点，<code>Fetch</code> 请求默认是不附带 <code>Cookies</code> 等信息的，在请求静态资源上这没有问题，而且节省了网络请求大小。但对于动态页面，则可能会因为请求缺失 <code>Cookies</code> 而存在问题。</p><p>此时可以给 <code>Fetch</code> 请求设置第二个参数。示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(fetchRequest, &#123; <span class="attr">credentials</span>: <span class="string">'include'</span> &#125; );</span><br></pre></td></tr></table></figure><p></p><h3 id="3-4-3-activate-事件"><a href="#3-4-3-activate-事件" class="headerlink" title="3.4.3 activate 事件"></a>3.4.3 activate 事件</h3><p>当安装完成后并进入激活状态，会触发 <code>activate</code> 事件。通过监听 <code>activate</code> 事件你可以做一些预处理，如对于旧版本的更新、对于无用缓存的清理等。</p><p>在下面的示例中，我们实现对旧版本的缓存资源清理：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cacheWhitelist = [<span class="string">'blog_cache_v1.6.0'</span>];</span><br><span class="line"></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 遍历当前的缓存，删除除 `blog_cache_v1.6.0` 之外的所有缓存</span></span><br><span class="line">        caches.keys().then(<span class="function"><span class="params">keyList</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>传给 <code>waitUntil()</code> 的 Promise 会阻塞其他的事件，直到它完成。这可以确保清理操作会在第一次 fetch 事件之前完成。在激活时也可执行 <code>clients.claim</code> 方法，更新所有客户端上的 Service Worker。具体参见前文的 <code>Service Worker 更新</code> 部分。</p><h3 id="3-4-4-push-事件"><a href="#3-4-4-push-事件" class="headerlink" title="3.4.4 push 事件"></a>3.4.4 push 事件</h3><p>push 事件是为推送准备的。不过首先你需要了解一下 <code>Notification API</code> 和 <code>PUSH API</code>(相关链接见后文)。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 ServiceWorker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。推送的实现有两步：</p><p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging<gcm>作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。</gcm></p><p>在页面上，使用 <code>PushManager.subscribe()</code> 来订阅推送服务。示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向用户申请通知权限，用户可以选择允许或禁止</span></span><br><span class="line"><span class="comment">// Notification.requestPermission 只有在页面上才可执行，Service Worker 内部不可申请权限</span></span><br><span class="line">Notification.requestPermission().then(<span class="function"><span class="params">grant</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(grant); <span class="comment">// 如果获得权限，会得到 granted</span></span><br><span class="line">    <span class="keyword">if</span> (Notification.permission === <span class="string">'denied'</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户拒绝了通知权限</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Permission for Notifications was denied'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg;</span><br><span class="line"><span class="keyword">const</span> applicationServerKey = <span class="string">'xxx'</span>; <span class="comment">// 应用服务器的公钥（base64 网址安全编码）</span></span><br><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="params">_reg</span> =&gt;</span> &#123;</span><br><span class="line">    reg = _reg;</span><br><span class="line">    <span class="comment">// 获取当前订阅的推送</span></span><br><span class="line">    <span class="keyword">return</span> reg.pushManager.getSubscription();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取的结果没有任何订阅，发起一个订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!subscription) &#123;</span><br><span class="line">        <span class="keyword">return</span> reg.pushManager.subscribe(&#123;</span><br><span class="line">            userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">            applicationServerKey: applicationServerKey</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 每一个会话会有一个独立的端点(endpoint)，用于推送时后端识别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"已订阅 endpoint:"</span>, subscription.endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscription) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'订阅成功！'</span>, subscription.endpoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做更多的事情，如将订阅信息发送给后端，用于后端推送识别</span></span><br><span class="line">    <span class="comment">// const key = subscription.getKey('p256dh');</span></span><br><span class="line">    <span class="comment">// updateStatus(subscription.endpoint, key, 'subscribe');</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Unable to subscribe to push.'</span>, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第二步比较简单，是在 Service Worker 中通过监听 <code>push</code> 事件对推送的消息作处理。示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 event.data 获取传递过来的数据，根据该数据做进一步的逻辑处理</span></span><br><span class="line">    <span class="keyword">const</span> obj = event.data.json();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑处理示例</span></span><br><span class="line">    <span class="keyword">if</span>(Notification.permission === <span class="string">'granted'</span> &amp;&amp; obj.action === <span class="string">'subscribe'</span>) &#123;</span><br><span class="line">        self.registration.showNotification(<span class="string">"Hi："</span>, &#123;</span><br><span class="line">            body: <span class="string">'订阅成功 ~'</span>,</span><br><span class="line">            icon: <span class="string">'/images/avatar/icon-80x80.png'</span>,</span><br><span class="line">            tag: <span class="string">'push'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>有个比较大的问题是，每个浏览器有它们自己的服务器用来处理消息推送。在国内 Google 大部分服务不可用的情况下，在 Chrome 中这个推送功能就没用了。另外还涉及后端的处理逻辑，这里不作细说，有兴趣可进一步参阅如下参考。</p><p><strong>关于推送和通知的更多参考：</strong></p><ul><li>GCM <a href="https://developers.google.com/cloud-messaging/gcm" target="_blank" rel="noopener">https://developers.google.com/cloud-messaging/gcm</a></li><li>Notification API <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a></li><li>PUSH API <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API</a></li><li>Using_the_Push_API <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API/Using_the_Push_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API/Using_the_Push_API</a></li><li>PushSubscription <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PushSubscription" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/PushSubscription</a></li><li>向网络应用添加推送通知 <a href="https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/</a></li><li><a href="https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/</a></li><li>【Service Worker】消息推送功能“全军覆没” <a href="https://75team.com/post/push-knock-the-door.html" target="_blank" rel="noopener">https://75team.com/post/push-knock-the-door.html</a></li><li><a href="https://developer.apple.com/notifications/safari-push-notifications/" target="_blank" rel="noopener">https://developer.apple.com/notifications/safari-push-notifications/</a></li></ul><h3 id="3-4-5-sync-事件"><a href="#3-4-5-sync-事件" class="headerlink" title="3.4.5 sync 事件"></a>3.4.5 sync 事件</h3><p>sync 事件由 <code>background sync</code> (后台同步)发出。background sync 是 Google 配合 SW 推出的 API，用于为 SW 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C WEB API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 <code>chrome://flags/#enable-experimental-web-platform-features</code> ，开启该功能，然后重启生效。</p><p>后台同步功能允许你一次性或按间隔请求后台数据同步，即使用户没有打开网站，仅唤醒了 ServiceWorker，也会如此。</p><p>当你从页面请求执行此操作的权限，用户将收到提示。后台同步适合于： 非紧急更新，特别是那些需要定期进行的更新，每次更新都发送一个推送通知会显得太频繁，如在某个时间推送一篇特色文章或一条消息通知，这在 native 应用中非常常见。</p><p>参考下面的示例。</p><p>A. 在页面注册 sync：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">swRegistration</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> swRegistration.sync.register(<span class="string">'myFirstSync'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>B. 在 SW 中监听 <code>sync</code> 事件：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> controller = navigator.serviceWorker.controller;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!controller) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.postMessage(msg, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 serviceWorker 注册成功后，页面上即可通过 navigator.serviceWorker.controller 发送消息给它</span></span><br><span class="line">navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'/test/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/test/'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">registration</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> sendMsg(<span class="string">'hello sw!'</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err));</span><br></pre></td></tr></table></figure><br>相关参考：<p></p><ul><li>background-sync <a href="https://developers.google.com/web/updates/2015/12/background-sync" target="_blank" rel="noopener">https://developers.google.com/web/updates/2015/12/background-sync</a></li><li><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#on-background-sync" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#on-background-sync</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncManager" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/SyncManager</a></li></ul><h3 id="3-4-6-message-事件-postMessage"><a href="#3-4-6-message-事件-postMessage" class="headerlink" title="3.4.6 message 事件(postMessage)"></a>3.4.6 message 事件(postMessage)</h3><p>ServiceWorker 运行于独立的沙盒中，无法直接访问当前页面的 DOM 等信息，但是通过 <code>postMessage</code> API，可以实现他们之间的消息传递。</p><p>跨文档的 postMessage 消息传输，需要获取接收方的文档句柄。那么当需要将消息从页面传输给 ServiceWorker 或从 ServiceWorker 传输给页面时，如何获取对应的文档句柄？我们参考下面的示例来了解。</p><p>A. 页面发消息给 serviceWorker</p><p>在页面上通过 <code>navigator.serviceWorker.controller</code> 获得 ServiceWorker 的句柄。但只有 ServiceWorker 注册成功后该句柄才会存在。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> controller = navigator.serviceWorker.controller;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!controller) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.postMessage(msg, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 serviceWorker 注册成功后，页面上即可通过 navigator.serviceWorker.controller 发送消息给它</span></span><br><span class="line">navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'/test/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/test/'</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">registration</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> sendMsg(<span class="string">'hello sw!'</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err));</span><br></pre></td></tr></table></figure><p></p><p>在 ServiceWorker 内部，可以通过监听 message 事件即可获得消息：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ev.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>B. ServiceWorker 发消息给页面</p><p>ServiceWorker 内部需要获取页面句柄，这个句柄要从 <code>self.clients</code> 上得到。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.clients.matchAll().then(<span class="function"><span class="params">clientList</span> =&gt;</span> &#123;</span><br><span class="line">    clientList.forEach(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">        client.postMessage(<span class="string">'Hi, I am send from Service worker！'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="3-4-7-online-offline-事件"><a href="#3-4-7-online-offline-事件" class="headerlink" title="3.4.7 online/offline 事件"></a>3.4.7 online/offline 事件</h3><p>当网络状态发生变化时，会触发 <code>online</code> 或 <code>offline</code> 事件。结合这两个事件，可以与 <code>Service Worker</code> 结合实现更好的离线使用体验，例如当网络发生改变时，替换/隐藏需要在线状态才能使用的链接导航等。</p><p>下面是一个监听 <code>offline</code> 的示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Notification.requestPermission().then(<span class="function"><span class="params">grant</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(<span class="string">"Hi，网络不给力哟"</span>, &#123;</span><br><span class="line">            body: <span class="string">'您的网络貌似离线了，不过访问过的页面还可以继续打开~'</span>,</span><br><span class="line">            icon: <span class="string">'/images/avatar/icon-80x80.png'</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        notification.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            notification.close();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="3-4-8-error-和-unhandledrejection-事件"><a href="#3-4-8-error-和-unhandledrejection-事件" class="headerlink" title="3.4.8 error 和 unhandledrejection 事件"></a>3.4.8 error 和 unhandledrejection 事件</h3><p>当 JS 执行发生错误，会触发 error 事件；当 Promise 类型的回调发生 reject 却没有 catch 处理，会触发 unhandledrejection 事件。</p><p>对于这类事件，前端应当作埋点上报，以便于统计监控和及时发现处理。一般情况下上报的信息应从 error 中读取，主要包括错误堆栈相关信息以便定位。参考如下示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">errorMessage, scriptURI, lineNumber, columnNumber, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reportError(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reportError(&#123;</span><br><span class="line">            message: errorMessage,</span><br><span class="line">            script: scriptURI,</span><br><span class="line">            line: lineNumber，</span><br><span class="line">            column: columnNumber</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>监听 <code>unhandledrejection</code> 事件：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    reportError(&#123;</span><br><span class="line">        message: event.reason</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="3-4-9-beforeinstallprompt-事件"><a href="#3-4-9-beforeinstallprompt-事件" class="headerlink" title="3.4.9 beforeinstallprompt 事件"></a>3.4.9 beforeinstallprompt 事件</h3><p>当发生 <code>Add to Homescreen</code> (A2HS, 添加到主屏幕)行为的请求时，会触发该事件。它发生于页面中，与 Service Worker 并没有直接关系。</p><p>如果你的站点符合 A2HS 的条件(具体参见后文介绍)，浏览器(chrome) 会根据默认的行为算法，来决定何时主动的向用户展示添加到首屏提示。另外，用户也可以通过 chrome 菜单中的 <code>添加到主屏幕</code> 选项主动添加。</p><p>可以在页面中通过监听 <code>beforeinstallprompt</code> 事件，决定是否屏蔽/延迟该行为，或者统计用户选择了允许还是拒绝。示例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deferredPrompt; <span class="comment">// 用于缓存 beforeinstallprompt 的事件对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeinstallprompt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 阻止该行为，只需要返回 false</span></span><br><span class="line">    <span class="comment">// event.preventDefault();</span></span><br><span class="line">    <span class="comment">// deferredPrompt = event;</span></span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计用户的选择</span></span><br><span class="line">    event.userChoice.then(<span class="function"><span class="keyword">function</span>(<span class="params">choiceResult</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(choiceResult.outcome); <span class="comment">// 为 dismissed 或 accepted</span></span><br><span class="line">        <span class="keyword">if</span>(choiceResult.outcome === <span class="string">'dismissed'</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'User cancelled home screen install'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'User added to home screen'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 beforeinstallprompt 事件中屏蔽了浏览器的默认行为，在页面中通过按钮让用户主动选择</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'addToHomeScreen'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deferredPrompt) &#123;</span><br><span class="line">        deferredPrompt.prompt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h2 id="4-Service-Worker-调试"><a href="#4-Service-Worker-调试" class="headerlink" title="4 Service Worker 调试"></a>4 Service Worker 调试</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/progressive-web-apps" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/progressive-web-apps</a></li></ul><h2 id="5-Service-Worker-安全问题"><a href="#5-Service-Worker-安全问题" class="headerlink" title="5 Service Worker 安全问题"></a>5 Service Worker 安全问题</h2><p>在这篇文章 <a href="https://www.l68.net/1294.html" target="_blank" rel="noopener">利用 Appcache 和 ServiceWorker 进行持久型 session hijacking 和 XSS</a> 中提到了服务器权限被拿下，或通过 Wifi 中间人劫持后，对访问者可以制造持久性攻击的问题。</p><p>其中 Appcache 主要利用的是 <code>cache-manifest</code> 文件也被缓存时，从站点方面无法进行更新，那么网站方面即使知道了这种问题，也是无能为力。这种 bug 不知道浏览器厂商方面后续是否有针对性处理。</p><p>对于 ServiceWorker 的利用，则是通过构造 ServiceWorker 的脚本并向用户注册。</p><p>想象一下，如果站点方面还没有 ServiceWorker 的意识，却被中间人提前利用了，用户被攻击了一次，却导致后续的访问都会被该 ServiceWorker 劫持。</p><h2 id="6-APP-Manifest-与添加到主屏幕"><a href="#6-APP-Manifest-与添加到主屏幕" class="headerlink" title="6 APP Manifest 与添加到主屏幕"></a>6 APP Manifest 与添加到主屏幕</h2><p>通过添加到主屏幕功能可以在用户桌面(主屏幕)上创建一个站点的快捷图标，实现和 Native APP 近似的使用体验。通过该图标打开的页面和浏览器中直接访问的体验有些不同，它在体验上更像 Native 应用：</p><ul><li>和 APP 一样在用户桌面(主屏幕)上存在图标</li><li>有 splash screen 启动屏</li><li>可以控制控制屏幕方向</li><li>可以设置全屏显示，没有浏览器的搜索框、导航栏</li></ul><p>要实现这一点的前提条件是：站点注册成功了 Service Worker；定义了一个 manifest 文件，并在页面中申明。</p><h3 id="6-1-定义-manifest-json-配置添加到主屏幕功能"><a href="#6-1-定义-manifest-json-配置添加到主屏幕功能" class="headerlink" title="6.1 定义 manifest.json 配置添加到主屏幕功能"></a>6.1 定义 manifest.json 配置添加到主屏幕功能</h3><ol><li>创建 <code>manifest.json</code> 文件，并将它放到你的站点目录中。</li><li>在所有页面引入该文件。</li><li>可以在 Service Worker 中监听 <code>beforeinstallprompt</code> 事件做一些应用内的行为处理。具体参见前文事件处理部分。</li></ol><p>在页面 head 区域添加如下内容：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"manifest"</span> href=<span class="string">"/manifest.json"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p><code>manifest.json</code> 内容示例(相关注释为了解释说明，正式使用应当删除注释)：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scope"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"gkl2013"</span>,</span><br><span class="line">  <span class="string">"short_name"</span>: <span class="string">"gkl2013"</span>,</span><br><span class="line">  <span class="string">"start_url"</span>: <span class="string">"/?from=homescreen"</span>,</span><br><span class="line">  <span class="string">"display"</span>: <span class="string">"standalone"</span>, <span class="comment">// chrome 58 beta 添加了取值 fullscreen 的支持，更像一个全屏应用</span></span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"每天知道多一点."</span>,</span><br><span class="line">  <span class="string">"dir"</span>: <span class="string">"rtl"</span>,</span><br><span class="line">  <span class="string">"lang"</span>: <span class="string">"cn"</span>,</span><br><span class="line">  <span class="string">"orientation"</span>: <span class="string">"portrait"</span>,</span><br><span class="line">  <span class="string">"theme_color"</span>: <span class="string">"#3f51b5"</span>,</span><br><span class="line">  <span class="string">"background_color"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">  <span class="string">"icons"</span>: [&#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"images/logo/48x48.webp"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"48x48"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/webp"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"images/logo/72x72.svg"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"72x72"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/svg"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"images/logo/96x96.png"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"96x96"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"images/logo/144x144.png"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"images/logo/hd.png"</span>,</span><br><span class="line">    <span class="string">"sizes"</span>: <span class="string">"168x168 192x192 256x256"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"prefer_related_applications"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"related_applications"</span>: [&#123;</span><br><span class="line">    <span class="string">"platform"</span>: <span class="string">"web"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"platform"</span>: <span class="string">"play"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://xxx"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"platform"</span>: <span class="string">"itunes"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最佳实践参考：</p><ul><li>所有页面都应添加引入代码</li><li>不要偷懒简化 icon 的配置。应为不同分辨率的屏幕提供不同的 icon。Chrome 会尝试使用最接近 48dp 的图标，比如在 2x 屏上使用 96px 的，在 3x屏上使用 144px 的。</li><li>short_name 会用于主屏幕图标名称，name 和 background_color 会用于 splash 启动屏幕上。</li><li>为 start_url 配置特殊的参数，可以用于统计从主屏幕打开的用户访问。</li></ul><h3 id="6-2-设置-IOS-Safari-上的添加至主屏幕元素"><a href="#6-2-设置-IOS-Safari-上的添加至主屏幕元素" class="headerlink" title="6.2 设置 IOS Safari 上的添加至主屏幕元素"></a>6.2 设置 IOS Safari 上的添加至主屏幕元素</h3><p>IOS 上 Safari 有自己的类似标准。方法很简单，在页面的 head 区域添加如下配置即可：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"apple-mobile-web-app-capable"</span> content=<span class="string">"yes"</span>&gt;</span><br><span class="line">&lt;meta name=<span class="string">"apple-mobile-web-app-status-bar-style"</span> content=<span class="string">"black"</span>&gt;</span><br><span class="line">&lt;meta name=<span class="string">"apple-mobile-web-app-title"</span> content=<span class="string">"gkl2013.top"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"apple-touch-icon"</span> href=<span class="string">"images/logo/152x152.png"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="6-3-设置-window10-贴片图标"><a href="#6-3-设置-window10-贴片图标" class="headerlink" title="6.3 设置 window10 贴片图标"></a>6.3 设置 window10 贴片图标</h3><p>在页面的 head 区域添加如下内容：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"msapplication-TileImage"</span> content=<span class="string">"images/logo/144x144.png"</span>&gt;</span><br><span class="line">&lt;meta name=<span class="string">"msapplication-TileColor"</span> content=<span class="string">"#2F3BA2"</span>&gt;</span><br></pre></td></tr></table></figure><p></p><p><strong>更多参考：</strong></p><ul><li><a href="https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners</a></li><li><a href="https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a></li></ul><h2 id="7-博客网站-PWA-快速改造参考"><a href="#7-博客网站-PWA-快速改造参考" class="headerlink" title="7 博客网站 PWA 快速改造参考"></a>7 博客网站 PWA 快速改造参考</h2><p>对于个人博客类站点，基于 PWA 的使用体验基本是相似的。可参考如下步骤为你的博客快速地引入 PWA：</p><ol><li>参考 <code>sw.js</code>，下载它并放到你的站点根目录</li><li>设计简单的 <code>offline.html</code> 用于离线降级显示。</li><li>参考 <code>manifest.json</code>，修改适合你的博客，放到站点根目录</li><li>在页面的 js 中加入注册 <code>sw.js</code> 的代码。参考前文 <code>Serveice Worker 注册</code> 部分示例</li><li>在站点页面模板的 <code>head</code> 区域，引入 <code>manilfest.json</code> 文件</li><li>在 PC 和手机上分别使用 Chrome 浏览器进行体验</li></ol><p>在页面中注册 ServiceWorker 代码参考：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 ServiceWorker</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regSW</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        navigator.serviceWorker</span><br><span class="line">            .register(<span class="string">'/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">            .then( <span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册成功！作用域为: '</span>, registration.scope);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker 注册失败: '</span>, err);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SW 消息处理</span></span><br><span class="line">        navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">window</span>.Notification || !<span class="built_in">window</span>.MessageChannel) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立一个消息管道，用于当前页面与 SW 之间的消息传递，也便于 SW 知道该消息的来源</span></span><br><span class="line">            <span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="built_in">window</span>.MessageChannel();</span><br><span class="line"></span><br><span class="line">            channel.port1.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'get Message: '</span>, e.data);</span><br><span class="line">                <span class="keyword">if</span> (!e.data) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 要求申请通知权限</span></span><br><span class="line">                <span class="keyword">if</span> (e.data.type === <span class="string">'applyNotify'</span>) &#123;</span><br><span class="line">                    <span class="built_in">window</span>.Notification.requestPermission().then(<span class="function"><span class="keyword">function</span>(<span class="params">grant</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">'申请通知权限被拒绝了！'</span>)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        reg.active.postMessage(&#123;<span class="attr">type</span>: <span class="string">'notify'</span>, <span class="attr">info</span>: e.data.info&#125;, [channel.port2]);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reg.active.postMessage(<span class="string">'hello'</span>, [channel.port2]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 掉线通知示例</span></span><br><span class="line">        $(<span class="built_in">window</span>).on(<span class="string">'offline'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            Notification.requestPermission().then(<span class="function"><span class="keyword">function</span> (<span class="params">grant</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (grant !== <span class="string">'granted'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(<span class="string">"Hi，网络不给力哟"</span>, &#123;</span><br><span class="line">                    body: <span class="string">'您的网络貌似离线了，不过访问过的页面还可以继续打开~'</span>,</span><br><span class="line">                    icon: <span class="string">'/images/avatar/icon-80x80.png'</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                notification.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    notification.close();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="8-其他相关参考"><a href="#8-其他相关参考" class="headerlink" title="8 其他相关参考"></a>8 其他相关参考</h2><ul><li><a href="https://w3c.github.io/ServiceWorker/" target="_blank" rel="noopener">https://w3c.github.io/ServiceWorker/</a></li><li><a href="https://www.w3.org/TR/service-workers/" target="_blank" rel="noopener">https://www.w3.org/TR/service-workers/</a></li><li><a href="https://github.com/w3c/ServiceWorker" target="_blank" rel="noopener">https://github.com/w3c/ServiceWorker</a></li><li>Using Service Workers <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers</a></li><li>Service_Worker_API <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API</a></li><li>Progressive Web Apps <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">https://developers.google.com/web/progressive-web-apps/</a></li><li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/getting-started/primers/service-workers</a></li><li><a href="https://developers.google.com/web/fundamentals/getting-started/codelabs/your-first-pwapp/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/getting-started/codelabs/your-first-pwapp/?hl=zh-cn</a></li><li>SW 离线指南 <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/</a></li><li>Service Workers’ API 信息图 <a href="https://github.com/delapuente/service-workers-101" target="_blank" rel="noopener">https://github.com/delapuente/service-workers-101</a></li><li>Service Workers 与离线缓存 <a href="https://segmentfault.com/a/1190000008491458" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008491458</a></li><li>【Service Worker】生命周期那些事儿 <a href="https://segmentfault.com/a/1190000007487049" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007487049</a></li><li>Service Worker 生命周期 <a href="https://segmentfault.com/a/1190000006061528" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006061528</a></li><li><a href="https://www.pangjian.me/2017/02/08/service-worker-offlinemode/" target="_blank" rel="noopener">https://www.pangjian.me/2017/02/08/service-worker-offlinemode/</a></li><li><a href="https://www.slideshare.net/patrickmeenan/service-workers-for-performance" target="_blank" rel="noopener">https://www.slideshare.net/patrickmeenan/service-workers-for-performance</a></li><li>PWA 在饿了么的实践经验 <a href="https://zhuanlan.zhihu.com/p/25800461" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25800461</a></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://gkl2013.top">gkl2013</a> 版权所有。如若转载，请注明出处：gkl2013（<a href="https://gkl2013.top/">https://gkl2013.top/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/03/01/Electron/" title="Electron绕坑指南"><i class="iconfont icon-prev"></i>Electron绕坑指南</a></div><div class="post__prev post__prev--right"></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">我的梦想是永不停歇的疯狂！</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/工具/">工具</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端开发/">前端开发</a><span class="block-list-count">8</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端工具/">前端工具</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/vpn/">vpn</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/SEO/">SEO</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/03/06/PWA_Service_Worker/" title="PWA Service Worker详解"><div class="item__cover"><img src="http://oxb3h3vd2.bkt.clouddn.com/18-03-07-pwa.png" alt="PWA Service Worker详解"></div><div class="item__info"><h3 class="item__title">PWA Service Worker详解</h3><span class="item__text">2018-03-06</span></div></a></li><li class="latest-post-item"><a href="/2018/03/01/Electron/" title="Electron绕坑指南"><div class="item__cover"><img src="http://oxb3h3vd2.bkt.clouddn.com/Electron_1.png" alt="Electron绕坑指南"></div><div class="item__info"><h3 class="item__title">Electron绕坑指南</h3><span class="item__text">2018-03-01</span></div></a></li><li class="latest-post-item"><a href="/2018/02/08/puppeteer/" title="windows下安装puppeteer"><div class="item__cover"><img src="http://oxb3h3vd2.bkt.clouddn.com/npm.png" alt="windows下安装puppeteer"></div><div class="item__info"><h3 class="item__title">windows下安装puppeteer</h3><span class="item__text">2018-02-08</span></div></a></li><li class="latest-post-item"><a href="/2018/02/03/搭建VPN/" title="搭建私有VPN"><div class="item__cover"><img src="http://oxb3h3vd2.bkt.clouddn.com/18-02-3/vpn.jpg" alt="搭建私有VPN"></div><div class="item__info"><h3 class="item__title">搭建私有VPN</h3><span class="item__text">2018-02-03</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/CSS/">CSS</a></li><li class="tag-item"><a class="tag-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-item"><a class="tag-link" href="/tags/Electron/">Electron</a></li><li class="tag-item"><a class="tag-link" href="/tags/HTML/">HTML</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/NPM/">NPM</a></li><li class="tag-item"><a class="tag-link" href="/tags/PWA/">PWA</a></li><li class="tag-item"><a class="tag-link" href="/tags/SASS/">SASS</a></li><li class="tag-item"><a class="tag-link" href="/tags/SEO/">SEO</a></li><li class="tag-item"><a class="tag-link" href="/tags/Service-Worker/">Service Worker</a></li><li class="tag-item"><a class="tag-link" href="/tags/VPN/">VPN</a></li><li class="tag-item"><a class="tag-link" href="/tags/Vue/">Vue</a></li><li class="tag-item"><a class="tag-link" href="/tags/WEB性能优化/">WEB性能优化</a></li><li class="tag-item"><a class="tag-link" href="/tags/WebStorm/">WebStorm</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Chongqing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>2532277986@qq.com</span></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="http://eux.baidu.com/" title="百度EUX" target="_blank">百度EUX</a></li><li class="list-item"><a href="https://aotu.io/index.html" title="凹凸实验室" target="_blank">凹凸实验室</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a> <a href="#">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/gkl2013" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="2532277986@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var tags=["PWA","Service Worker"],gitalk=new Gitalk({clientID:"69fd2a576312a7346746",clientSecret:"9a2d103a2866520693aae0eb643abd7d1feb1d27",repo:"gkl2013.github.io",owner:"gkl2013",admin:["gkl2013"],id:"PWA Service Worker详解"});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>